"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8842],{8276:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>u});var s=t(6070),i=t(5296),l=t(5360),o=t(1201);const a={},r="Going further",c={id:"going-further",title:"Going further",description:"If you have not read the quick start guide yet, please read it first.",source:"@site/docs/going-further.mdx",sourceDirName:".",slug:"/going-further",permalink:"/docs/going-further",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Quick start",permalink:"/docs/quick-start"},next:{title:"Agent libraries",permalink:"/docs/agents/"}},d={},u=[{value:"Project overview",id:"project-overview",level:2},{value:"What are we building?",id:"what-are-we-building",level:3},{value:"Tairu concepts we will cover",id:"tairu-concepts-we-will-cover",level:3},{value:"Setting up the project",id:"setting-up-the-project",level:2},{value:"Project creation",id:"project-creation",level:3},{value:"Adding dependencies",id:"adding-dependencies",level:3},{value:"Database setup",id:"database-setup",level:3},{value:"Poll creation",id:"poll-creation",level:2},{value:"Setting the poll question",id:"setting-the-poll-question",level:3},{value:"Adding choices",id:"adding-choices",level:3},{value:"Saving the poll",id:"saving-the-poll",level:3},{value:"Serving the Tile handler",id:"serving-the-tile-handler",level:3},{value:"Poll display",id:"poll-display",level:2},{value:"Loading from the database",id:"loading-from-the-database",level:3},{value:"Displaying the poll",id:"displaying-the-poll",level:3},{value:"Handling submissions",id:"handling-submissions",level:3},{value:"Wrapping up",id:"wrapping-up",level:2},{value:"Running the server",id:"running-the-server",level:3},{value:"Full handler code",id:"full-handler-code",level:3},{value:"Next steps",id:"next-steps",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"going-further",children:"Going further"})}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["If you have not read the ",(0,s.jsx)(n.a,{href:"/docs/quick-start",children:"quick start guide"})," yet, please read it first."]}),(0,s.jsx)(n.p,{children:"This guide assumes you are already familiar with the concepts presented in the quick start guide."})]}),"\n",(0,s.jsx)(n.h2,{id:"project-overview",children:"Project overview"}),"\n",(0,s.jsx)(n.h3,{id:"what-are-we-building",children:"What are we building?"}),"\n",(0,s.jsx)(n.p,{children:"In this guide, we'll create a Tiles server that can be used to create simple polls (with up to 5 choices of answers) and display and interact with the polls."}),"\n",(0,s.jsx)(n.p,{children:"This guide uses TypeScript to make the types used explicit, but you can use plain JavaScript if you prefer."}),"\n",(0,s.jsx)(n.h3,{id:"tairu-concepts-we-will-cover",children:"Tairu concepts we will cover"}),"\n",(0,s.jsx)(n.p,{children:"This guide will show how to use the following concepts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supporting multiple Tile handlers in a single server."}),"\n",(0,s.jsx)(n.li,{children:"Using route parameters with Tile handlers."}),"\n",(0,s.jsx)(n.li,{children:"Interacting with a database from Tile handlers."}),"\n",(0,s.jsx)(n.li,{children:"Managing stateful interactions with Tiles."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["This guide is intentionally limited in scope and focuses only on presenting some features of the Tairu framework. It ",(0,s.jsx)(n.strong,{children:"does not"})," cover subjects such as input sanitization, error handling, access control or other generic application topics."]})}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-the-project",children:"Setting up the project"}),"\n",(0,s.jsx)(n.h3,{id:"project-creation",children:"Project creation"}),"\n",(0,s.jsxs)(n.p,{children:["Create a new folder for your project and initialize the ",(0,s.jsx)(n.code,{children:"package.json"})," file, for example using your package manager:"]}),"\n",(0,s.jsxs)(l.A,{groupId:"package-manager",children:[(0,s.jsx)(o.A,{value:"npm",label:"npm",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"npm init -y\n"})})}),(0,s.jsx)(o.A,{value:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"pnpm init\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"adding-dependencies",children:"Adding dependencies"}),"\n",(0,s.jsx)(n.p,{children:"We'll add the following dependencies to our project:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tairu"}),": the Tairu CLI, that we will use to start a local server."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@tairu/handler"}),": the library that we will use to create our Tile handlers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"@tairu/protocol"}),": protocol type definitions, only needed if you are using TypeScript."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"level"}),": a simple ",(0,s.jsx)(n.a,{href:"https://github.com/Level/level",children:"key-value database"})," we will use to store the polls."]}),"\n"]}),"\n",(0,s.jsxs)(l.A,{groupId:"package-manager",children:[(0,s.jsx)(o.A,{value:"npm",label:"npm",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"npm install tairu @tairu/handler @tairu/protocol level\n"})})}),(0,s.jsx)(o.A,{value:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"pnpm add tairu @tairu/handler @tairu/protocol level\n"})})})]}),"\n",(0,s.jsx)(n.h3,{id:"database-setup",children:"Database setup"}),"\n",(0,s.jsxs)(n.p,{children:["Let's create a ",(0,s.jsx)(n.code,{children:"handler.tsx"})," (or ",(0,s.jsx)(n.code,{children:"handler.jsx"})," if you are using JavaScript) file in our project folder and add the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" showLineNumbers',children:"import { Level } from 'level'\n\n// Questions have a title and a list of choices\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\n// Answers are a mapping of DID to choice index\ntype PollAnswers = Record<string, number> \n\nconst db = new Level('polls-db')\nconst questionsDB = db.sublevel<string, PollQuestion>('questions', { valueEncoding: 'json' })\nconst answersDB = db.sublevel<string, PollAnswers>('answers', { valueEncoding: 'json' })\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here, we define the types for a poll question (line 4) and answers (line 10) and create our Level databases to store them."}),"\n",(0,s.jsxs)(n.p,{children:["The answers are stored as a mapping of the unique user ",(0,s.jsx)(n.a,{href:"/docs/concepts#dids",children:"DID"})," that submitted the answer to the index of their choice."]}),"\n",(0,s.jsx)(n.h2,{id:"poll-creation",children:"Poll creation"}),"\n",(0,s.jsx)(n.p,{children:"Now that we can store polls, we'll create a Tile handler to create them."}),"\n",(0,s.jsx)(n.h3,{id:"setting-the-poll-question",children:"Setting the poll question"}),"\n",(0,s.jsx)(n.p,{children:"We'll start by defining the Tile that gets rendered by default, when no action has been submitted yet. This Tile will prompt the user to create a poll by first defining the question:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {1-8,24-35} showLineNumbers',children:"import {\n  Box,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n} from '@tairu/handler'\nimport { Level } from 'level'\n\n// Questions have a title and a list of choices\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\n// Answers are a mapping of DID to choice index\ntype PollAnswers = Record<string, number> \n\nconst db = new Level('polls-db')\nconst questionsDB = db.sublevel<string, PollQuestion>('questions', { valueEncoding: 'json' })\nconst answersDB = db.sublevel<string, PollAnswers>('answers', { valueEncoding: 'json' })\n\nconst createPollHandler: TileHandler = async (request) => {\n  if (request.action == null) {\n    return (\n      <Tile\n        title=\"Create a new poll\"\n        input={<TextInput label=\"Poll question\" />}\n        actions={<SubmitAction label=\"Next\" />}>\n        <Text>Create a new poll by first setting a question</Text>\n      </Tile>\n    )\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adding-choices",children:"Adding choices"}),"\n",(0,s.jsx)(n.p,{children:"Once the question is defined, the action will be provided to the request and we can display another Tile, this time asking to add a first choice."}),"\n",(0,s.jsxs)(n.p,{children:["Because we will need to display a Tile for each choice, we'll create the ",(0,s.jsx)(n.code,{children:"displayPollChoice"})," helper function and use it in our ",(0,s.jsx)(n.code,{children:"createPollHandler"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {24-50,64-84} showLineNumbers',children:'import {\n  Box,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n} from \'@tairu/handler\'\nimport { Level } from \'level\'\n\n// Questions have a title and a list of choices\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\n// Answers are a mapping of DID to choice index\ntype PollAnswers = Record<string, number> \n\nconst db = new Level(\'polls-db\')\nconst questionsDB = db.sublevel<string, PollQuestion>(\'questions\', { valueEncoding: \'json\' })\nconst answersDB = db.sublevel<string, PollAnswers>(\'answers\', { valueEncoding: \'json\' })\n\ntype CreatePollState = {\n  question: string\n  choices: Array<string>\n  save?: boolean\n}\n\nfunction displayPollChoice(state: CreatePollState) {\n  const choicesCount = state.choices.length\n  const saveAction = <SubmitAction key="save" label="Save poll" state={{ ...state, save: true }} />\n  const actions =\n    // Max number of choices, only action is to save the poll\n    choicesCount === 4 ? (\n      saveAction\n    ) : // At least 2 choices must be provided\n    choicesCount < 2 ? (\n      <SubmitAction label="Next" state={state} />\n    ) : (\n      // 2 options: add another choice or save the poll\n      [<SubmitAction key="next" label="Add another choice" state={state} />, saveAction]\n    )\n\n  return (\n    <Tile title="Create a new poll" input={<TextInput label="Choice value" />} actions={actions}>\n      <Text>Add choice number {choicesCount + 1} to the poll</Text>\n    </Tile>\n  )\n}\n\nconst createPollHandler: TileHandler = async (request) => {\n  if (request.action == null) {\n    return (\n      <Tile\n        title="Create a new poll"\n        input={<TextInput label="Poll question" />}\n        actions={<SubmitAction label="Next" />}>\n        <Text>Create a new poll by first setting a question</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.type !== \'did/submit\') {\n    return (\n      <Tile title="Poll error">\n        <Text>unsupported action</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.state == null) {\n    // If there is no state in the action, it\'s setting the question\n    return displayPollChoice({ question: request.action.value as string, choices: [] })\n  }\n\n  const state = request.action.state as CreatePollState\n  const newChoice = request.action.value as string\n  const choices = newChoice === \'\' ? state.choices : [...state.choices, newChoice]\n\n  if (!state.save || choices.length < 2) {\n    // Add another choice to the poll\n    return displayPollChoice({ ...state, choices })\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CreatePollState"})," defined line 24 represents the state of our poll creation. It is submitted along with the input value when using the submit action, so we can use it to keep track of the state of our poll during the creation process."]}),"\n",(0,s.jsxs)(n.p,{children:["In our ",(0,s.jsx)(n.code,{children:"createPollHandler"}),", we add the following logic:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Line 64, we check if the action has the expected type, or display an error message."}),"\n",(0,s.jsx)(n.li,{children:"Line 72, we check if the action has state. If it doesn't, it means the poll was just created with the question."}),"\n",(0,s.jsx)(n.li,{children:"Line 79, we update our list of choices, unless the submitted value is an empty string."}),"\n",(0,s.jsx)(n.li,{children:"Finally at line 81, we check if we should continue to display the form to add a choice."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"saving-the-poll",children:"Saving the poll"}),"\n",(0,s.jsx)(n.p,{children:"Once all the choices have been added, we can save the poll to the database:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {3,87-97} showLineNumbers',children:'import {\n  Box,\n  OpenAction,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n} from \'@tairu/handler\'\nimport { Level } from \'level\'\n\n// Questions have a title and a list of choices\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\n// Answers are a mapping of DID to choice index\ntype PollAnswers = Record<string, number> \n\nconst db = new Level(\'polls-db\')\nconst questionsDB = db.sublevel<string, PollQuestion>(\'questions\', { valueEncoding: \'json\' })\nconst answersDB = db.sublevel<string, PollAnswers>(\'answers\', { valueEncoding: \'json\' })\n\ntype CreatePollState = {\n  question: string\n  choices: Array<string>\n  save?: boolean\n}\n\nfunction displayPollChoice(state: CreatePollState) {\n  const choicesCount = state.choices.length\n  const saveAction = <SubmitAction key="save" label="Save poll" state={{ ...state, save: true }} />\n  const actions =\n    // Max number of choices, only action is to save the poll\n    choicesCount === 4 ? (\n      saveAction\n    ) : // At least 2 choices must be provided\n    choicesCount < 2 ? (\n      <SubmitAction label="Next" state={state} />\n    ) : (\n      // 2 options: add another choice or save the poll\n      [<SubmitAction key="next" label="Add another choice" state={state} />, saveAction]\n    )\n\n  return (\n    <Tile title="Create a new poll" input={<TextInput label="Choice value" />} actions={actions}>\n      <Text>Add choice number {choicesCount + 1} to the poll</Text>\n    </Tile>\n  )\n}\n\nconst createPollHandler: TileHandler = async (request) => {\n  if (request.action == null) {\n    return (\n      <Tile\n        title="Create a new poll"\n        input={<TextInput label="Poll question" />}\n        actions={<SubmitAction label="Next" />}>\n        <Text>Create a new poll by first setting a question</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.type !== \'did/submit\') {\n    return (\n      <Tile title="Poll error">\n        <Text>unsupported action</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.state == null) {\n    // If there is no state in the action, it\'s setting the question\n    return displayPollChoice({ question: request.action.value as string, choices: [] })\n  }\n\n  const state = request.action.state as CreatePollState\n  const newChoice = request.action.value as string\n  const choices = newChoice === \'\' ? state.choices : [...state.choices, newChoice]\n\n  if (!state.save || choices.length < 2) {\n    // Add another choice to the poll\n    return displayPollChoice({ ...state, choices })\n  }\n\n  // Save the poll to the database\n  const id = crypto.randomUUID()\n  await questionsDB.put(id, { title: state.question, choices })\n\n  return (\n    <Tile\n      title="Poll created!"\n      actions={<OpenAction label="Open poll" uri={`${request.urlPrefix}/polls/${id}`} />}>\n      <Text>The poll was successfully created!</Text>\n    </Tile>\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In order for the user to open the newly created poll, we use an ",(0,s.jsx)(n.code,{children:"OpenAction"})," element (line 94) with the URL of the poll. This URL uses the ",(0,s.jsx)(n.code,{children:"urlPrefix"})," defined in the handler ",(0,s.jsx)(n.code,{children:"request"})," argument and the ID of the newly created poll."]}),"\n",(0,s.jsx)(n.h3,{id:"serving-the-tile-handler",children:"Serving the Tile handler"}),"\n",(0,s.jsxs)(n.p,{children:["Now that our poll creation handler is ready, we need to serve it using the ",(0,s.jsx)(n.code,{children:"handle"})," function from the ",(0,s.jsx)(n.code,{children:"@tairu/handler"})," package (line 9) and using it as default export to serve our ",(0,s.jsx)(n.code,{children:"createPollHandler"})," (line 101):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {9,101} showLineNumbers',children:'import {\n  Box,\n  OpenAction,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n  handle,\n} from \'@tairu/handler\'\nimport { Level } from \'level\'\n\n// Questions have a title and a list of choices\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\n// Answers are a mapping of DID to choice index\ntype PollAnswers = Record<string, number> \n\nconst db = new Level(\'polls-db\')\nconst questionsDB = db.sublevel<string, PollQuestion>(\'questions\', { valueEncoding: \'json\' })\nconst answersDB = db.sublevel<string, PollAnswers>(\'answers\', { valueEncoding: \'json\' })\n\ntype CreatePollState = {\n  question: string\n  choices: Array<string>\n  save?: boolean\n}\n\nfunction displayPollChoice(state: CreatePollState) {\n  const choicesCount = state.choices.length\n  const saveAction = <SubmitAction key="save" label="Save poll" state={{ ...state, save: true }} />\n  const actions =\n    // Max number of choices, only action is to save the poll\n    choicesCount === 4 ? (\n      saveAction\n    ) : // At least 2 choices must be provided\n    choicesCount < 2 ? (\n      <SubmitAction label="Next" state={state} />\n    ) : (\n      // 2 options: add another choice or save the poll\n      [<SubmitAction key="next" label="Add another choice" state={state} />, saveAction]\n    )\n\n  return (\n    <Tile title="Create a new poll" input={<TextInput label="Choice value" />} actions={actions}>\n      <Text>Add choice number {choicesCount + 1} to the poll</Text>\n    </Tile>\n  )\n}\n\nconst createPollHandler: TileHandler = async (request) => {\n  if (request.action == null) {\n    return (\n      <Tile\n        title="Create a new poll"\n        input={<TextInput label="Poll question" />}\n        actions={<SubmitAction label="Next" />}>\n        <Text>Create a new poll by first setting a question</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.type !== \'did/submit\') {\n    return (\n      <Tile title="Poll error">\n        <Text>unsupported action</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.state == null) {\n    // If there is no state in the action, it\'s setting the question\n    return displayPollChoice({ question: request.action.value as string, choices: [] })\n  }\n\n  const state = request.action.state as CreatePollState\n  const newChoice = request.action.value as string\n  const choices = newChoice === \'\' ? state.choices : [...state.choices, newChoice]\n\n  if (!state.save || choices.length < 2) {\n    // Add another choice to the poll\n    return displayPollChoice({ ...state, choices })\n  }\n\n  // Save the poll to the database\n  const id = crypto.randomUUID()\n  await questionsDB.put(id, { title: state.question, choices })\n\n  return (\n    <Tile\n      title="Poll created!"\n      actions={<OpenAction label="Open poll" uri={`${request.urlPrefix}/polls/${id}`} />}>\n      <Text>The poll was successfully created!</Text>\n    </Tile>\n  )\n}\n\nexport default handle(createPollHandler)\n'})}),"\n",(0,s.jsx)(n.p,{children:"At this stage, our handler should be ready to be served using the Tairu CLI. However, before trying to create polls, let's add another handler to display the polls."}),"\n",(0,s.jsx)(n.h2,{id:"poll-display",children:"Poll display"}),"\n",(0,s.jsx)(n.p,{children:"Similar to the poll creation handler, we will add another handler responsible for loading polls from the database, displaying the answers stored and handling submissions."}),"\n",(0,s.jsx)(n.h3,{id:"loading-from-the-database",children:"Loading from the database"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" showLineNumbers',children:"// Previous code omitted for brevity\n\nconst displayPollHandler: TileHandler<{ id: string }> = async ({ action, pathParams }) => {\n  const pollID = pathParams.id\n  let pollQuestion: PollQuestion\n  let pollAnswers: PollAnswers\n\n  try {\n    pollQuestion = await questionsDB.get(pollID)\n  } catch {\n    return (\n      <Tile title=\"Poll not found\">\n        <Text>Poll not found</Text>\n      </Tile>\n    )\n  }\n\n  try {\n    pollAnswers = await answersDB.get(pollID)\n  } catch {\n    pollAnswers = {}\n  }\n}\n\nexport default handle({\n  '/': createPollHandler,\n  '/polls/:id': displayPollHandler,\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's start from the ",(0,s.jsx)(n.code,{children:"handle"})," function at line 25: instead of providing a single handler, we provide an object mapping paths to handlers.\nOur poll creation will continue to be served at the root (",(0,s.jsx)(n.code,{children:"/"})," path), while our polls will be served at ",(0,s.jsx)(n.code,{children:"/polls/:id"})," where ",(0,s.jsx)(n.code,{children:":id"})," is a parameter that will be provided to the handler."]}),"\n",(0,s.jsxs)(n.p,{children:["In our ",(0,s.jsx)(n.code,{children:"displayPollHandler"}),", we can retrieve the poll identifier using the ",(0,s.jsx)(n.code,{children:"pathParams"})," object from the ",(0,s.jsx)(n.code,{children:"request"})," argument at line 4. Using the identifier, we can retrieve the question (line 9) and answers (line 19) from our database."]}),"\n",(0,s.jsxs)(n.p,{children:["Because LevelDB throws errors for missing keys, we need to handle those cases with ",(0,s.jsx)(n.code,{children:"try"}),"/",(0,s.jsx)(n.code,{children:"catch"}),". In case of error when retrieving the question, we return a Tile displaying an error message, while we default to using an empty object for answers."]}),"\n",(0,s.jsx)(n.h3,{id:"displaying-the-poll",children:"Displaying the poll"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have loaded our poll and answers from the database, we can display them in a Tile."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {3-4,6-8,16,20-23,46-75} showLineNumbers',children:"import {\n  Box,\n  type BoxElement,\n  type BoxProps,\n  OpenAction,\n  Option,\n  type OptionElement,\n  OptionsInput,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n  handle,\n} from '@tairu/handler'\nimport type { BoxStyleV0 } from '@tairu/protocol'\n\n// Code omitted for brevity\n\nfunction Stack(props: BoxProps) {\n  const style: BoxStyleV0 = { ...(props.style ?? {}), flexDirection: 'column' }\n  return <Box {...props} style={style} />\n}\n\nconst displayPollHandler: TileHandler<{ id: string }> = async ({ action, pathParams }) => {\n  const pollID = pathParams.id\n  let pollQuestion: PollQuestion\n  let pollAnswers: PollAnswers\n\n  try {\n    pollQuestion = await questionsDB.get(pollID)\n  } catch {\n    return (\n      <Tile title=\"Poll not found\">\n        <Text>Poll not found</Text>\n      </Tile>\n    )\n  }\n\n  try {\n    pollAnswers = await answersDB.get(pollID)\n  } catch {\n    pollAnswers = {}\n  }\n\n  const answersCounts = new Array(pollQuestion.choices.length).fill(0)\n  for (const choice of Object.values(pollAnswers)) {\n    answersCounts[choice]++\n  }\n\n  const answersList: Array<BoxElement> = []\n  const choicesOptions: Array<OptionElement> = []\n  for (const [index, choice] of pollQuestion.choices.entries()) {\n    const key = index.toString()\n    answersList.push(\n      <Box key={key}>\n        <Text>\n          {choice}: {answersCounts[index]}\n        </Text>\n      </Box>,\n    )\n    choicesOptions.push(<Option key={key} label={choice} value={index} />)\n  }\n\n  return (\n    <Tile\n      title={pollQuestion.title}\n      input={<OptionsInput>{choicesOptions}</OptionsInput>}\n      actions={<SubmitAction label=\"Submit\" />}>\n      <Stack>\n        <Text>{pollQuestion.title}</Text>\n        <Stack>{answersList}</Stack>\n      </Stack>\n    </Tile>\n  )\n}\n\nexport default handle({\n  '/': createPollHandler,\n  '/polls/:id': displayPollHandler,\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Before going into the details of the answers list and options input, let's first look at a new component we're adding at line 20: ",(0,s.jsx)(n.code,{children:"Stack"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Thought Tairu is not a React framework and does not support React functionalities such as hooks, it is possible to create custom components using Tairu's primitive components such as ",(0,s.jsx)(n.code,{children:"Box"}),". Here, our ",(0,s.jsx)(n.code,{children:"Stack"})," simply sets a default ",(0,s.jsx)(n.code,{children:"style"})," to the component to display its children as column rather than a row."]}),"\n",(0,s.jsx)(n.p,{children:"To display the answers, we iterate over the answers object to count the number of votes for each choice (line 47) and then iterate over the poll's choices to display create both the list of answers (line 55) and the list of options (line 62) that can be submitted."}),"\n",(0,s.jsxs)(n.p,{children:["Finally, the ",(0,s.jsx)(n.code,{children:"Tile"})," element we return uses the ",(0,s.jsx)(n.code,{children:"OptionsInput"})," input to provide to options that can be submitted and displays the list of anwers."]}),"\n",(0,s.jsx)(n.h3,{id:"handling-submissions",children:"Handling submissions"}),"\n",(0,s.jsx)(n.p,{children:"The last step for our poll handler to be complete is to handle submissions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx" {24-36} showLineNumbers',children:"// Previous code omitted for brevity\n\nconst displayPollHandler: TileHandler<{ id: string }> = async ({ action, pathParams }) => {\n  const pollID = pathParams.id\n  let pollQuestion: PollQuestion\n  let pollAnswers: PollAnswers\n\n  try {\n    pollQuestion = await questionsDB.get(pollID)\n  } catch {\n    return (\n      <Tile title=\"Poll not found\">\n        <Text>Poll not found</Text>\n      </Tile>\n    )\n  }\n\n  try {\n    pollAnswers = await answersDB.get(pollID)\n  } catch {\n    pollAnswers = {}\n  }\n\n  if (request.action?.type === 'did/submit') {\n    const did = request.action.did\n    const choice = (request.action.value as Array<number>)[0]\n    if (choice != null) {\n      // Save provided choice\n      pollAnswers[did] = choice\n      await answersDB.put(pollID, pollAnswers)\n    } else if (pollAnswers[did] != null) {\n      // No choice provided, remove existing one\n      delete pollAnswers[did]\n      await answersDB.put(pollID, pollAnswers)\n    }\n  }\n\n  const answersCounts = new Array(pollQuestion.choices.length).fill(0)\n  for (const choice of Object.values(pollAnswers)) {\n    answersCounts[choice]++\n  }\n\n  const answersList: Array<BoxElement> = []\n  const choicesOptions: Array<OptionElement> = []\n  for (const [index, choice] of pollQuestion.choices.entries()) {\n    const key = index.toString()\n    answersList.push(\n      <Box key={key}>\n        <Text>\n          {choice}: {answersCounts[index]}\n        </Text>\n      </Box>,\n    )\n    choicesOptions.push(<Option key={key} label={choice} value={index} />)\n  }\n\n  return (\n    <Tile\n      title={pollQuestion.title}\n      input={<OptionsInput>{choicesOptions}</OptionsInput>}\n      actions={<SubmitAction label=\"Submit\" />}>\n      <Stack>\n        <Text>{pollQuestion.title}</Text>\n        <Stack>{answersList}</Stack>\n      </Stack>\n    </Tile>\n  )\n}\n\nexport default handle({\n  '/': createPollHandler,\n  '/polls/:id': displayPollHandler,\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"The action handling logic (line 24) happens before the display logic so the submitted choice can be taken into account when couting the answers. Here we simply check if a value is provided and must be saved (line 27) or when no value is submitted but a previous choice was saved, we remove it (line 31)."}),"\n",(0,s.jsxs)(n.p,{children:["By updating the ",(0,s.jsx)(n.code,{children:"pollAnswers"})," object based on the submission before counting the choices (line 39), we can ensure the submission is taken into account."]}),"\n",(0,s.jsx)(n.h2,{id:"wrapping-up",children:"Wrapping up"}),"\n",(0,s.jsx)(n.h3,{id:"running-the-server",children:"Running the server"}),"\n",(0,s.jsxs)(n.p,{children:["Let's update our ",(0,s.jsx)(n.code,{children:"package.json"})," to add a ",(0,s.jsx)(n.code,{children:"start"})," script using the Tairu CLI:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'{\n  "scripts": {\n    "start": "tairu serve ./handler.tsx"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can then use the package manager to start the server:"}),"\n",(0,s.jsxs)(l.A,{groupId:"package-manager",children:[(0,s.jsx)(o.A,{value:"npm",label:"npm",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"npm start\n"})})}),(0,s.jsx)(o.A,{value:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"pnpm start\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["That's it! We can now open the poll creation Tile on ",(0,s.jsx)(n.code,{children:"http://localhost:3210"})," to create polls, and interact with them at the dynamically generated poll URLs."]}),"\n",(0,s.jsx)(n.h3,{id:"full-handler-code",children:"Full handler code"}),"\n",(0,s.jsx)(n.p,{children:"Here is the full handler code from this guide, for reference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="handler.tsx"',children:'import {\n  Box,\n  type BoxElement,\n  type BoxProps,\n  OpenAction,\n  Option,\n  type OptionElement,\n  OptionsInput,\n  SubmitAction,\n  Text,\n  TextInput,\n  Tile,\n  type TileHandler,\n  handle,\n} from \'@tairu/handler\'\nimport type { BoxStyleV0 } from \'@tairu/protocol\'\nimport { Level } from \'level\'\n\ntype PollQuestion = {\n  title: string\n  choices: Array<string>\n}\n\ntype PollAnswers = Record<string, number> // DID to choice index\n\nconst db = new Level(\'polls-db\')\nconst questionsDB = db.sublevel<string, PollQuestion>(\'questions\', { valueEncoding: \'json\' })\nconst answersDB = db.sublevel<string, PollAnswers>(\'answers\', { valueEncoding: \'json\' })\n\ntype CreatePollState = {\n  question: string\n  choices: Array<string>\n  save?: boolean\n}\n\nfunction displayPollChoice(state: CreatePollState) {\n  const choicesCount = state.choices.length\n  const saveAction = <SubmitAction key="save" label="Save poll" state={{ ...state, save: true }} />\n  const actions =\n    // Max number of choices, only action is to save the poll\n    choicesCount === 4 ? (\n      saveAction\n    ) : // At least 2 choices must be provided\n    choicesCount < 2 ? (\n      <SubmitAction label="Next" state={state} />\n    ) : (\n      // 2 options: add another choice or save the poll\n      [<SubmitAction key="next" label="Add another choice" state={state} />, saveAction]\n    )\n\n  return (\n    <Tile title="Create a new poll" input={<TextInput label="Choice value" />} actions={actions}>\n      <Text>Add choice number {choicesCount + 1} to the poll</Text>\n    </Tile>\n  )\n}\n\nconst createPollHandler: TileHandler = async (request) => {\n  if (request.action == null) {\n    return (\n      <Tile\n        title="Create a new poll"\n        input={<TextInput label="Poll question" />}\n        actions={<SubmitAction label="Next" />}>\n        <Text>Create a new poll by first setting a question</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.type !== \'did/submit\') {\n    return (\n      <Tile title="Poll error">\n        <Text>Unsupported action</Text>\n      </Tile>\n    )\n  }\n\n  if (request.action.state == null) {\n    // If there is no state in the action, it\'s setting the question\n    return displayPollChoice({ question: request.action.value as string, choices: [] })\n  }\n\n  const state = request.action.state as CreatePollState\n  const newChoice = request.action.value as string\n  const choices = newChoice === \'\' ? state.choices : [...state.choices, newChoice]\n\n  if (!state.save || choices.length < 2) {\n    // Add another choice to the poll\n    return displayPollChoice({ ...state, choices })\n  }\n\n  // Save the poll to the database\n  const id = crypto.randomUUID()\n  await questionsDB.put(id, { title: state.question, choices })\n\n  return (\n    <Tile\n      title="Poll created!"\n      actions={<OpenAction label="Open poll" uri={`${request.urlPrefix}/polls/${id}`} />}>\n      <Text>The poll was successfully created!</Text>\n    </Tile>\n  )\n}\n\nfunction Stack(props: BoxProps) {\n  const style: BoxStyleV0 = { ...(props.style ?? {}), flexDirection: \'column\' }\n  return <Box {...props} style={style} />\n}\n\nconst displayPollHandler: TileHandler<{ id: string }> = async (request) => {\n  const pollID = request.pathParams.id\n  let pollQuestion: PollQuestion\n  let pollAnswers: PollAnswers\n\n  try {\n    pollQuestion = await questionsDB.get(pollID)\n  } catch {\n    return (\n      <Tile title="Poll not found">\n        <Text>Poll not found</Text>\n      </Tile>\n    )\n  }\n\n  try {\n    pollAnswers = await answersDB.get(pollID)\n  } catch {\n    pollAnswers = {}\n  }\n\n  if (request.action?.type === \'did/submit\') {\n    const did = request.action.did\n    const choice = (request.action.value as Array<number>)[0]\n    if (choice != null) {\n      // Save provided choice\n      pollAnswers[did] = choice\n      await answersDB.put(pollID, pollAnswers)\n    } else if (pollAnswers[did] != null) {\n      // No choice provided, remove existing one\n      delete pollAnswers[did]\n      await answersDB.put(pollID, pollAnswers)\n    }\n  }\n\n  const answersCounts = new Array(pollQuestion.choices.length).fill(0)\n  for (const choice of Object.values(pollAnswers)) {\n    answersCounts[choice]++\n  }\n\n  const answersList: Array<BoxElement> = []\n  const choicesOptions: Array<OptionElement> = []\n  for (const [index, choice] of pollQuestion.choices.entries()) {\n    const key = index.toString()\n    answersList.push(\n      <Box key={key}>\n        <Text>\n          {choice}: {answersCounts[index]}\n        </Text>\n      </Box>,\n    )\n    choicesOptions.push(<Option key={key} label={choice} value={index} />)\n  }\n\n  return (\n    <Tile\n      title={pollQuestion.title}\n      input={<OptionsInput>{choicesOptions}</OptionsInput>}\n      actions={<SubmitAction label="Submit" />}>\n      <Stack>\n        <Text>{pollQuestion.title}</Text>\n        <Stack>{answersList}</Stack>\n      </Stack>\n    </Tile>\n  )\n}\n\nexport default handle({\n  \'/\': createPollHandler,\n  \'/polls/:id\': displayPollHandler,\n})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(n.p,{children:"Congratulations for going through this guide! It hopefully gave you a good overview of how to start using Tairu to create Tile handlers."}),"\n",(0,s.jsxs)(n.p,{children:["To dig deeper, make sure to go over the ",(0,s.jsx)(n.a,{href:"/docs/concepts",children:"core concepts"})," and the ",(0,s.jsx)(n.a,{href:"/docs/protocol",children:"protocol"})," to get a better understanding of the possibilities."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1201:(e,n,t)=>{t.d(n,{A:()=>o});t(758);var s=t(3526);const i={tabItem:"tabItem__9L9"};var l=t(6070);function o(e){let{children:n,hidden:t,className:o}=e;return(0,l.jsx)("div",{role:"tabpanel",className:(0,s.A)(i.tabItem,o),hidden:t,children:n})}},5360:(e,n,t)=>{t.d(n,{A:()=>j});var s=t(758),i=t(3526),l=t(536),o=t(5557),a=t(1780),r=t(5861),c=t(7418),d=t(9116);function u(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:i}}=e;return{value:n,label:t,attributes:s,default:i}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function x(e){let{queryString:n=!1,groupId:t}=e;const i=(0,o.W6)(),l=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,r.aZ)(l),(0,s.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(i.location.search);n.set(l,e),i.replace({...i.location,search:n.toString()})}),[l,i])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,l=h(e),[o,r]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:l}))),[c,u]=x({queryString:t,groupId:i}),[g,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,l]=(0,d.Dv)(t);return[i,(0,s.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:i}),v=(()=>{const e=c??g;return p({value:e,tabValues:l})?e:null})();(0,a.A)((()=>{v&&r(v)}),[v]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);r(e),u(e),m(e)}),[u,m,l]),tabValues:l}}var m=t(8560);const v={tabList:"tabList_K8wU",tabItem:"tabItem_HUVu"};var f=t(6070);function w(e){let{className:n,block:t,selectedValue:s,selectValue:o,tabValues:a}=e;const r=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.a_)(),d=e=>{const n=e.currentTarget,t=r.indexOf(n),i=a[t].value;i!==s&&(c(n),o(i))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=r.indexOf(e.currentTarget)+1;n=r[t]??r[0];break}case"ArrowLeft":{const t=r.indexOf(e.currentTarget)-1;n=r[t]??r[r.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:a.map((e=>{let{value:n,label:t,attributes:l}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>r.push(e),onKeyDown:u,onClick:d,...l,className:(0,i.A)("tabs__item",v.tabItem,l?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:l}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===l));return e?(0,s.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==l})))})}function y(e){const n=g(e);return(0,f.jsxs)("div",{className:(0,i.A)("tabs-container",v.tabList),children:[(0,f.jsx)(w,{...n,...e}),(0,f.jsx)(b,{...n,...e})]})}function j(e){const n=(0,m.default)();return(0,f.jsx)(y,{...e,children:u(e.children)},String(n))}},5296:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(758);const i={},l=s.createContext(i);function o(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);